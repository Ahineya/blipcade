{"name": "testcart", "code": "const APP_STATE = {\n    LOADING: 'loading',\n    LOADED: 'loaded',\n    DEVELOPMENT: 'development'\n};\nclass State {\n    appState = APP_STATE.LOADING;\n    FONT_SIZE = {\n        width: 5,\n        height: 7\n    };\n    FPS = 30;\n    FRAME_TIME = 1000 / this.FPS;\n    lastUpdateTime = Date.now();\n    lastDrawTime = Date.now();\n    frames = 0;\n    seconds = 0;\n    objects = [];\n    particleManager = null;\n    constructor(){}\n}\nconst state = new State();\nconst PICO8_COLORS = {\n    0: 0x00,\n    1: 0x2E,\n    2: 0x56,\n    3: 0x15,\n    4: 0x83,\n    5: 0x5B,\n    6: 0xBC,\n    7: 0xEF,\n    8: 0xC9,\n    9: 0xE1,\n    10: 0xEC,\n    11: 0x1F,\n    12: 0x45,\n    13: 0x89,\n    14: 0xDA,\n    15: 0xE9\n};\nconst PICO8_COLORS1 = {\n    0: 0x00,\n    1: 0x2E,\n    2: 0x56,\n    3: 0x15,\n    4: 0x83,\n    5: 0x5B,\n    6: 0xBC,\n    7: 0xEF,\n    8: 0xC9,\n    9: 0xE1,\n    10: 0xEC,\n    11: 0x1F,\n    12: 0x45,\n    13: 0x89,\n    14: 0xDA,\n    15: 0xE9\n};\nconst gridcolor = 12;\nclass Background {\n    constructor(){\n        this.t = 0;\n        this.list = [\n            \"starfield\",\n            \"loopy\",\n            \"grid\",\n            \"balls\",\n            \"flurry\",\n            \"ballspiral\",\n            \"flight\",\n            \"circles\",\n            \"rainbow\",\n            \"spiral\",\n            \"matrix\"\n        ];\n        this.rand = [];\n        this.rand2 = [];\n        this.current = null;\n        this.currentName = null;\n        this.star_sx = 64;\n        this.star_sy = 64;\n        this.star_cutoff = 12;\n        this.stars = [];\n        this.spots = [];\n        this.backgroundTypes = {\n            loopy: {\n                color: PICO8_COLORS1[0],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[0],\n                hfg: PICO8_COLORS1[15],\n                pbg: PICO8_COLORS1[1],\n                load: ()=>{\n                    this.rand = Array.from({\n                        length: 65536\n                    }, ()=>Math.random() * 16);\n                },\n                draw: ()=>{\n                    this.rand.forEach((p, i)=>{\n                        const x = i % 256;\n                        const y = Math.floor(i / 256);\n                        Graphics.putPixel(x, y, PICO8_COLORS1[Math.floor(Math.random() * 17)]);\n                    });\n                }\n            },\n            flurry: {\n                color: PICO8_COLORS1[0],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[0],\n                hfg: PICO8_COLORS1[15],\n                pbg: PICO8_COLORS1[1],\n                load: ()=>{\n                    this.rand = [];\n                    this.rand2 = [];\n                    for(let n = 0; n < 256; n++){\n                        this.rand.push(Math.random() * 256);\n                        this.rand2.push(Math.random() * 256);\n                    }\n                },\n                draw: ()=>{\n                    const p = [\n                        1,\n                        1,\n                        13,\n                        13,\n                        2,\n                        14,\n                        6\n                    ];\n                    for(let i = 0; i < 256; i++){\n                        const z = Math.floor(i / 40) + 1;\n                        Graphics.drawFilledCircle((this.rand[i] - this.t * z * z) % 140 - 8, this.rand2[i], z, PICO8_COLORS1[p[z]] || 0xfe);\n                    }\n                    this.t += 0.05;\n                }\n            },\n            balls: {\n                color: PICO8_COLORS1[0],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[2],\n                hfg: PICO8_COLORS1[1],\n                pbg: PICO8_COLORS1[8],\n                load: ()=>{\n                    for(let n = 0; n < 500; n++)this.rand.push(Math.random() * 9);\n                },\n                draw: ()=>{\n                    Graphics.drawFilledCircle(64, 64, 64, PICO8_COLORS1[7]);\n                    this.t += 0.01;\n                }\n            },\n            rainbow: {\n                color: PICO8_COLORS1[2],\n                mfg: PICO8_COLORS1[1],\n                mbg: PICO8_COLORS1[7],\n                hfg: PICO8_COLORS1[2],\n                pbg: PICO8_COLORS1[2],\n                draw: ()=>{\n                    const m = 12;\n                    this.t += 0.05;\n                    for(let n = 0; n < m * m; n++){\n                        const x = n % m;\n                        const y = Math.floor(n / m);\n                        Graphics.drawFilledCircle(x * 12, y * 12, 12 + 4 * Math.cos(this.t + y / 5) + 4 * Math.sin(this.t + x / 7), PICO8_COLORS1[8 + (x + y) % 8] || 0xfe);\n                    }\n                }\n            },\n            spiral: {\n                color: PICO8_COLORS1[1],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[5],\n                hfg: PICO8_COLORS1[6],\n                pbg: PICO8_COLORS1[0],\n                draw: ()=>{\n                    const s = 64;\n                    this.t += 0.0001;\n                    let x = s, y = s;\n                    for(let i = 1; i <= 350; i++){\n                        const j = i * this.t;\n                        const u = x, v = y;\n                        x = x + j * Math.sin(j);\n                        y = y + j * Math.cos(j);\n                        Graphics.drawLine(u, v, x, y, PICO8_COLORS1[7 + Math.floor(i / 60)] || 0xfe);\n                    }\n                }\n            },\n            circles: {\n                color: PICO8_COLORS1[2],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[1],\n                hfg: PICO8_COLORS1[15],\n                pbg: PICO8_COLORS1[0],\n                draw: ()=>{\n                    this.t += 0.01;\n                    for(let k = 0; k <= 16; k++)for(let n = 1; n <= 9; n++){\n                        const h = k / 16 + this.t;\n                        Graphics.drawCircle(64 + Math.cos(h + this.t / 3) * n * 8, 64 + Math.sin(h) * (n * n + Math.cos(this.t) * 16), n, PICO8_COLORS1[11 - Math.floor(n / 3)] || 0xfe);\n                    }\n                }\n            },\n            ballspiral: {\n                color: PICO8_COLORS1[9],\n                mfg: PICO8_COLORS1[0],\n                mbg: PICO8_COLORS1[7],\n                hfg: PICO8_COLORS1[4],\n                pbg: PICO8_COLORS1[4],\n                draw: ()=>{\n                    let x = 64, y = 64, r = 1, a = 0;\n                    for(let i = 0; i <= 150; i++){\n                        Graphics.drawFilledCircle(x, y, r / 2, PICO8_COLORS1[6 + i % 3] || 0xfe);\n                        x += Math.cos(a) * r;\n                        y += Math.sin(a) * r;\n                        r += 1 / 4;\n                        a += this.t / 5;\n                    }\n                    this.t += 0.002;\n                }\n            },\n            grid: {\n                color: PICO8_COLORS1[0],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[2],\n                hfg: PICO8_COLORS1[13],\n                pbg: PICO8_COLORS1[2],\n                draw: ()=>{\n                    const w = 127;\n                    const n = 15;\n                    this.t += 0.75;\n                    for(let i = 0; i <= n; i++){\n                        const z = i * n + this.t % n;\n                        const y = w * n / z + 32;\n                        Graphics.drawLine(0, y, w, y, PICO8_COLORS1[gridcolor]);\n                        const v = i + this.t % n / n - n / 2;\n                        Graphics.drawLine(v * 9 + 64, 40, v * 60 + 64, w, PICO8_COLORS1[gridcolor] || 0xfe);\n                    }\n                }\n            },\n            flight: {\n                color: PICO8_COLORS1[0],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[1],\n                hfg: PICO8_COLORS1[4],\n                pbg: PICO8_COLORS1[5],\n                draw: ()=>{\n                    const n = 32;\n                    const sin_t_over_300 = Math.sin(this.t / 300);\n                    const t_mod_n = this.t % n;\n                    const c = sin_t_over_300;\n                    const sin_t_over_9 = c / 9;\n                    const sin_t_over_3 = c / 3;\n                    const const1 = sin_t_over_3 + 1;\n                    const make = (y, color)=>{\n                        for(let i = 0; i <= n; i++){\n                            const z = (i * n + t_mod_n) / 1500;\n                            for(let j = -n; j <= n; j++){\n                                const x = (j * 0.7 + c) / z + y;\n                                const y_pos = (-j * sin_t_over_9 + const1) / z + y;\n                                Graphics.putPixel(x, y_pos, PICO8_COLORS1[color] || 0xfe);\n                            }\n                        }\n                    };\n                    this.t -= 2;\n                    make(5, 8);\n                    make(40, 9);\n                    make(70, 10);\n                }\n            },\n            matrix: {\n                color: PICO8_COLORS1[0],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[3],\n                hfg: PICO8_COLORS1[11],\n                pbg: PICO8_COLORS1[3],\n                draw: ()=>{\n                    for(let j = 3; j <= 99; j++){\n                        let c = 11;\n                        const x = j * 593;\n                        for(let y = 1; y <= x % c; y++){\n                            const n = Math.pow(j, y) % 7 + 1;\n                            const __char = \"5&y$%z?$*\".charAt(n - 1);\n                            text(__char, x % 126, (this.t + x) * j / 8 % 256 - y * 6, PICO8_COLORS1[c] || 0xfe);\n                            c = 3;\n                        }\n                    }\n                    this.t += 0.7;\n                }\n            },\n            starfield: {\n                color: PICO8_COLORS1[0],\n                mfg: PICO8_COLORS1[7],\n                mbg: PICO8_COLORS1[1],\n                hfg: PICO8_COLORS1[4],\n                pbg: PICO8_COLORS1[5],\n                load: ()=>{\n                    this.stars = [];\n                    this.spots = [];\n                },\n                update: ()=>{\n                    for(let i = 0; i < 2; i++)if (this.stars.length < 100) {\n                        let star = {\n                            x: this.star_sx,\n                            y: this.star_sy,\n                            d: Math.random(),\n                            spd: i + 1\n                        };\n                        let center_x = 64;\n                        let center_y = 64;\n                        let distance = Math.sqrt(Math.pow(star.x - center_x, 2) + Math.pow(star.y - center_y, 2));\n                        while(distance < 32){\n                            star.x = Math.random() * 256;\n                            star.y = Math.random() * 256;\n                            distance = Math.sqrt(Math.pow(star.x - center_x, 2) + Math.pow(star.y - center_y, 2));\n                        }\n                        this.stars.push({\n                            x: this.star_sx,\n                            y: this.star_sy,\n                            d: Math.random(),\n                            spd: i + 1\n                        });\n                    }\n                    this.stars = this.stars.filter((s)=>{\n                        s.d += 1;\n                        s.x += Math.cos(s.d * Math.PI * 2) * s.spd;\n                        s.y += Math.sin(s.d * Math.PI * 2) * s.spd;\n                        if (s.d > this.star_cutoff - s.spd) for(let i = 1; i <= Math.floor(s.spd); i++)this.spots.push({\n                            x: s.x - Math.cos(s.d * Math.PI * 2) * s.spd / i,\n                            y: s.y - Math.sin(s.d * Math.PI * 2) * s.spd / i,\n                            d: s.spd * 2\n                        });\n                        return !(s.x < -32 || s.x > 256 || s.y < -16 || s.y > 256);\n                    });\n                    this.spots = this.spots.filter((s)=>{\n                        s.d -= 1;\n                        return s.d >= 0;\n                    });\n                },\n                draw: ()=>{\n                    this.stars.forEach((s)=>{\n                        Graphics.putPixel(s.x, s.y, PICO8_COLORS1[7]);\n                    });\n                    this.spots.forEach((s)=>{\n                        Graphics.putPixel(s.x, s.y, PICO8_COLORS1[5]);\n                    });\n                }\n            }\n        };\n    }\n    createStar() {\n        const angle = Math.random() * Math.PI * 2;\n        return {\n            x: this.star_sx,\n            y: this.star_sy,\n            d: angle,\n            spd: Math.random() * 0.5 + 0.1\n        };\n    }\n    load(stageId) {\n        let bgp = this.list[stageId];\n        this.current = this.backgroundTypes[bgp];\n        this.currentName = bgp;\n        this.rand = [];\n        this.rand2 = [];\n        this.t = 0;\n        if (this.current && this.current.load) this.current.load();\n    }\n    next() {\n        this.load((this.list.indexOf(this.currentName) + 1) % this.list.length);\n    }\n    update() {\n        this.t += 0.01;\n        if (this.current && this.current.update) this.current.update();\n    }\n    draw() {\n        if (this.current && this.current.draw) this.current.draw();\n    }\n}\nfunction init() {\n    Graphics.setTransparentColor(255);\n    state.SPRITES = {\n        CURSOR: 0\n    };\n    state.color = 0;\n    state.frameCount = 0;\n    state.lastFPSUpdate = Date.now();\n    state.currentFPS = 0;\n    const background = new Background();\n    background.load(0);\n    state.background = background;\n    state.keyStates = {};\n    let playerEntity = ECS.createEntity();\n    let somethingEntity = ECS.createEntity();\n    log(`Entity 1: ${playerEntity}`);\n    log(`Entity 2: ${somethingEntity}`);\n    let positionComponent = {\n        x: 10.0,\n        y: 20.0\n    };\n    let velocityComponent = {\n        vx: 1.0,\n        vy: 1.5\n    };\n    let healthComponent = {\n        hp: 100\n    };\n    ECS.addComponent(playerEntity, \"Position\", positionComponent);\n    ECS.addComponent(playerEntity, \"Velocity\", velocityComponent);\n    ECS.addComponent(playerEntity, \"Sprite\", {\n        spriteID: 0,\n        flipX: false,\n        flipY: false\n    });\n    ECS.addComponent(somethingEntity, \"Position\", {\n        x: 5.0,\n        y: 15.0\n    });\n    ECS.addComponent(somethingEntity, \"Health\", healthComponent);\n    ECS.forEachEntity([\n        \"Position\",\n        \"Velocity\"\n    ], (entityID, pos, vel)=>{\n        pos.x += vel.vx;\n        pos.y += vel.vy;\n        log(`Entity ${entityID} moved to position ${pos.x}, ${pos.y}`);\n    });\n    ECS.forEachEntity([\n        \"Health\"\n    ], function(entityID, health) {\n        log(`Entity ${entityID} has health ${health.hp}`);\n    });\n    for(let i = 0; i < 100; i++){\n        let entity = ECS.createEntity();\n        ECS.addComponent(entity, \"Position\", {\n            x: Math.random() * 256,\n            y: Math.random() * 256\n        });\n        ECS.addComponent(entity, \"Sprite\", {\n            spriteID: 0,\n            flipX: false,\n            flipY: false\n        });\n    }\n}\nfunction update() {\n    const currentTime = Date.now();\n    const elapsed = currentTime - state.lastUpdateTime;\n    if (elapsed >= state.FRAME_TIME) {\n        state.frameCount++;\n        if (currentTime - state.lastFPSUpdate >= 1000) {\n            state.currentFPS = state.frameCount;\n            state.frameCount = 0;\n            state.lastFPSUpdate = currentTime;\n        }\n    }\n    Object.keys(state.keyStates).forEach((key)=>{\n        if (state.keyStates[key] === 'pressed') state.keyStates[key] = 'held';\n        else if (state.keyStates[key] === 'released') state.keyStates[key] = 'up';\n    });\n    if (Input.isKeyPressed(32)) {\n        if (state.keyStates[32] !== 'held' && state.keyStates[32] !== 'pressed') {\n            state.keyStates[32] = 'pressed';\n            state.background.next();\n        }\n    } else if (state.keyStates[32] === 'held' || state.keyStates[32] === 'pressed') state.keyStates[32] = 'released';\n    state.background.update();\n    state.keyJustPressed = false;\n}\nfunction draw() {\n    const currentTime = Date.now();\n    const elapsed = currentTime - state.lastDrawTime;\n    Graphics.fillScreen(0);\n    if (elapsed >= state.FRAME_TIME) {\n        state.lastDrawTime = currentTime - elapsed % state.FRAME_TIME;\n        state.color = (state.color + 1) % 255;\n    }\n    state.background.draw();\n    text(state.background.currentName || \"\", 1, 1);\n    ECS.forEachEntity([\n        \"Position\",\n        \"Sprite\"\n    ], (entity)=>{\n        const pos = ECS.getComponent(entity, \"Position\");\n        const sprite = ECS.getComponent(entity, \"Sprite\");\n        Graphics.drawSprite(pos.x, pos.y, sprite.spriteID, 0, sprite.flipX, sprite.flipY);\n    });\n    const mousePos = Input.getMousePos();\n    Graphics.drawSprite(mousePos.x, mousePos.y, state.SPRITES.CURSOR, false, false);\n    drawFPSCounter();\n}\nglobalThis.draw = draw;\nglobalThis.update = update;\nglobalThis.init = init;\nfunction drawFPSCounter() {\n    const fpsText = `fps: ${state.currentFPS}`;\n    text(fpsText, 1, 2, PICO8_COLORS[0]);\n    text(fpsText, 3, 2, PICO8_COLORS[0]);\n    text(fpsText, 2, 3, PICO8_COLORS[0]);\n    text(fpsText, 2, 1, PICO8_COLORS[0]);\n    text(fpsText, 2, 2, PICO8_COLORS[7]);\n}\n", "spritesheets": [{"texture": {"width": 13, "height": 13, "data": "00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 FF FF FF FF FF FF FF FF FF FF FF 00 EF 00 FF FF FF FF FF FF FF FF FF FF 00 EF EF 00 FF FF FF FF FF FF FF FF FF 00 EF EF EF 00 FF FF FF FF FF FF FF FF 00 EF EF EF EF 00 FF FF FF FF FF FF FF 00 EF EF EF EF EF 00 FF FF FF FF FF FF 00 EF EF EF EF EF EF 00 FF FF FF FF FF 00 EF EF EF EF 00 00 00 FF FF FF FF FF 00 EF 00 EF EF 00 FF FF FF FF FF FF FF 00 00 FF 00 EF EF 00 FF FF FF FF FF FF FF FF FF 00 EF EF 00 FF FF FF FF FF FF FF FF FF FF 00 00 FF FF FF FF FF FF FF"}, "sprites": [{"x": 0, "y": 0, "width": 8, "height": 13, "flags": 0}]}]}