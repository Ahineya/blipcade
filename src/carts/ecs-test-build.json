{"name": "ECS Test", "code": "const APP_STATE = {\n    LOADING: 'loading',\n    LOADED: 'loaded',\n    DEVELOPMENT: 'development'\n};\nclass State {\n    appState = APP_STATE.LOADING;\n    FONT_SIZE = {\n        width: 5,\n        height: 7\n    };\n    FPS = 30;\n    FRAME_TIME = 1000 / this.FPS;\n    lastUpdateTime = Date.now();\n    lastDrawTime = Date.now();\n    frames = 0;\n    seconds = 0;\n    objects = [];\n    particleManager = null;\n    constructor(){}\n}\nconst state = new State();\nconst PICO8_COLORS = {\n    0: 0x00,\n    1: 0x2E,\n    2: 0x56,\n    3: 0x15,\n    4: 0x83,\n    5: 0x5B,\n    6: 0xBC,\n    7: 0xEF,\n    8: 0xC9,\n    9: 0xE1,\n    10: 0xEC,\n    11: 0x1F,\n    12: 0x45,\n    13: 0x89,\n    14: 0xDA,\n    15: 0xE9\n};\nclass ParticlesSystem {\n    constructor(){\n        const particleEmitterComponent = {\n            name: \"Particle Emitter\",\n            position: {\n                x: 60,\n                y: 60\n            },\n            emissionRate: 2000,\n            particleLifetime: 0.5,\n            initialVelocity: {\n                x: 0,\n                y: 2\n            },\n            velocityVariation: 20\n        };\n        this.gradient = [];\n        for(let i = 0; i < 8; i++)this.gradient.push(160 + 5 * i + 1);\n        const particleEmitterEntity = ECS.createEntity();\n        ECS.addComponent(particleEmitterEntity, \"ParticleEmitter\", particleEmitterComponent);\n    }\n    update(deltaTime) {\n        deltaTime = deltaTime / 1000;\n        this.updateEmitter(deltaTime);\n        this.updateParticles(deltaTime);\n        this.emitParticles(deltaTime);\n    }\n    updateEmitter(deltaTime) {\n        ECS.forEachEntity([\n            \"ParticleEmitter\"\n        ], (_, emitter)=>{\n            const mouse = Input.getMousePos();\n            emitter.position.x = mouse.x;\n            emitter.position.y = mouse.y;\n        });\n    }\n    updateParticles(deltaTime) {\n        ECS.forEachEntity([\n            \"Particle\"\n        ], (entity, particle)=>{\n            particle.position.x += particle.velocity.x * deltaTime;\n            particle.position.y += particle.velocity.y * deltaTime;\n            particle.lifetime -= deltaTime;\n            particle.color = Math.min(6, particle.color + 1);\n            particle.size = Math.max(0, particle.size - 0.1);\n            if (particle.lifetime <= 0) ECS.destroyEntity(entity);\n        });\n    }\n    emitParticles(deltaTime) {\n        ECS.forEachEntity([\n            \"ParticleEmitter\"\n        ], (_, emitter)=>{\n            const particlesToEmit = emitter.emissionRate * deltaTime;\n            const wholeParticles = Math.floor(particlesToEmit);\n            const fractionalPart = particlesToEmit - wholeParticles;\n            for(let i = 0; i < wholeParticles; i++)this.emitParticle(emitter);\n            if (Math.random() < fractionalPart) this.emitParticle(emitter);\n        });\n    }\n    emitParticle(emitter) {\n        const particleEntity = ECS.createEntity();\n        const angle = -Math.PI / 2 + Math.random() * Math.PI / 4 - Math.PI / 8;\n        const speed = emitter.initialVelocity.y + Math.random() * emitter.velocityVariation;\n        const velocity = {\n            x: Math.cos(angle) * speed,\n            y: Math.sin(angle) * speed\n        };\n        const particle = {\n            name: `Particle ${particleEntity}`,\n            position: {\n                x: emitter.position.x,\n                y: emitter.position.y\n            },\n            velocity,\n            lifetime: emitter.particleLifetime,\n            size: 3,\n            color: 0\n        };\n        ECS.addComponent(particleEntity, \"Particle\", particle);\n    }\n    draw() {\n        ECS.forEachEntity([\n            \"Particle\"\n        ], (_, particle)=>{\n            const color = particle.color;\n            const size = particle.size;\n            const x = particle.position.x;\n            const y = particle.position.y;\n            Graphics.drawFilledCircle(x, y, size, this.gradient[color] || 0xFA);\n        });\n    }\n}\nfunction init() {\n    Graphics.setTransparentColor(255);\n    state.SPRITES = {\n        CURSOR: 0\n    };\n    state.frameCount = 0;\n    state.lastFPSUpdate = Date.now();\n    state.currentFPS = 0;\n    state.keyStates = {};\n    state.particlesSystem = new ParticlesSystem();\n}\nfunction update() {\n    const currentTime = Date.now();\n    const elapsed = currentTime - state.lastUpdateTime;\n    if (elapsed >= state.FRAME_TIME) {\n        state.frameCount++;\n        if (currentTime - state.lastFPSUpdate >= 1000) {\n            state.currentFPS = state.frameCount;\n            state.frameCount = 0;\n            state.lastFPSUpdate = currentTime;\n        }\n    }\n    Object.keys(state.keyStates).forEach((key)=>{\n        if (state.keyStates[key] === 'pressed') state.keyStates[key] = 'held';\n        else if (state.keyStates[key] === 'released') state.keyStates[key] = 'up';\n    });\n    if (Input.isKeyPressed(32)) {\n        if (state.keyStates[32] !== 'held' && state.keyStates[32] !== 'pressed') {\n            state.keyStates[32] = 'pressed';\n            state.background.next();\n        }\n    } else if (state.keyStates[32] === 'held' || state.keyStates[32] === 'pressed') state.keyStates[32] = 'released';\n    state.particlesSystem.update(state.FRAME_TIME);\n    state.keyJustPressed = false;\n}\nfunction draw() {\n    const currentTime = Date.now();\n    const elapsed = currentTime - state.lastDrawTime;\n    Graphics.fillScreen(0);\n    if (elapsed >= state.FRAME_TIME) {\n        state.lastDrawTime = currentTime - elapsed % state.FRAME_TIME;\n        state.color = (state.color + 1) % 255;\n    }\n    state.particlesSystem.draw();\n    const mousePos = Input.getMousePos();\n    Graphics.drawSprite(mousePos.x, mousePos.y, state.SPRITES.CURSOR, false, false);\n    drawFPSCounter();\n}\nglobalThis.draw = draw;\nglobalThis.update = update;\nglobalThis.init = init;\nfunction drawFPSCounter() {\n    const fpsText = `fps: ${state.currentFPS}`;\n    text(fpsText, 1, 2, PICO8_COLORS[0]);\n    text(fpsText, 3, 2, PICO8_COLORS[0]);\n    text(fpsText, 2, 3, PICO8_COLORS[0]);\n    text(fpsText, 2, 1, PICO8_COLORS[0]);\n    text(fpsText, 2, 2, PICO8_COLORS[7]);\n}\n", "spritesheets": [{"texture": {"width": 13, "height": 13, "data": "00 FF FF FF FF FF FF FF FF FF FF FF FF 00 00 FF FF FF FF FF FF FF FF FF FF FF 00 EF 00 FF FF FF FF FF FF FF FF FF FF 00 EF EF 00 FF FF FF FF FF FF FF FF FF 00 EF EF EF 00 FF FF FF FF FF FF FF FF 00 EF EF EF EF 00 FF FF FF FF FF FF FF 00 EF EF EF EF EF 00 FF FF FF FF FF FF 00 EF EF EF EF EF EF 00 FF FF FF FF FF 00 EF EF EF EF 00 00 00 FF FF FF FF FF 00 EF 00 EF EF 00 FF FF FF FF FF FF FF 00 00 FF 00 EF EF 00 FF FF FF FF FF FF FF FF FF 00 EF EF 00 FF FF FF FF FF FF FF FF FF FF 00 00 FF FF FF FF FF FF FF"}, "sprites": [{"x": 0, "y": 0, "width": 8, "height": 13, "flags": 0}]}]}