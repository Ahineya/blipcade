{"name": "testcart", "code": "class Mouse_ {\n    #listeners = new Map();\n    #state = {\n        x: 0,\n        y: 0,\n        left: false,\n        right: false\n    };\n    constructor(){\n        this.#listeners.set('move', []);\n        this.#listeners.set('leftDown', []);\n        this.#listeners.set('leftUp', []);\n    }\n    get coords() {\n        return {\n            x: this.#state.x,\n            y: this.#state.y\n        };\n    }\n    addEventListener(event, callback) {\n        this.#listeners.set(event, [\n            ...this.#listeners.get(event),\n            callback\n        ]);\n        return ()=>{\n            this.removeEventListener(event, callback);\n        };\n    }\n    removeEventListener(event, callback) {\n        this.#listeners.set(event, this.#listeners.get(event).filter((listener)=>listener !== callback));\n    }\n    #emit(event, data) {\n        const listeners = this.#listeners.get(event);\n        if (listeners) listeners.forEach((listener)=>listener(data));\n    }\n    mouseUpdate(mouseState) {\n        const x = mouseState.x;\n        const y = mouseState.y;\n        const left = mouseState.left;\n        const right = mouseState.right;\n        if (x !== this.#state.x || y !== this.#state.y) {\n            this.#state.x = x;\n            this.#state.y = y;\n            this.#emit('move', {\n                x,\n                y\n            });\n        }\n        if (left !== this.#state.left) {\n            this.#state.left = left;\n            this.#emit(left ? 'leftDown' : 'leftUp', {\n                x,\n                y\n            });\n        }\n        if (right !== this.#state.right) {\n            this.#state.right = right;\n            this.#emit(right ? 'rightDown' : 'rightUp', {\n                x,\n                y\n            });\n        }\n    }\n}\nconst Mouse = new Mouse_();\nconst APP_STATE = {\n    LOADING: 'loading',\n    LOADED: 'loaded',\n    DEVELOPMENT: 'development'\n};\nclass State {\n    appState = APP_STATE.LOADING;\n    FONT_SIZE = {\n        width: 5,\n        height: 7\n    };\n    FPS = 30;\n    FRAME_TIME = 1000 / this.FPS;\n    lastUpdateTime = Date.now();\n    lastDrawTime = Date.now();\n    frames = 0;\n    seconds = 0;\n    objects = [];\n    particleManager = null;\n    constructor(){}\n}\nconst state = new State();\nconst PICO8_COLORS = {\n    0: 0x00,\n    1: 0x2E,\n    2: 0x56,\n    3: 0x15,\n    4: 0x83,\n    5: 0x5B,\n    6: 0xBC,\n    7: 0xEF,\n    8: 0xC9,\n    9: 0xE1,\n    10: 0xEC,\n    11: 0x1F,\n    12: 0x45,\n    13: 0x89,\n    14: 0xDA,\n    15: 0xE9\n};\nconst gridcolor = 12;\nclass Background {\n    constructor(){\n        this.t = 0;\n        this.list = [\n            \"loopy\",\n            \"starfield\",\n            \"grid\",\n            \"balls\",\n            \"flurry\",\n            \"ballspiral\",\n            \"flight\",\n            \"circles\",\n            \"rainbow\",\n            \"spiral\",\n            \"matrix\"\n        ];\n        this.rand = [];\n        this.rand2 = [];\n        this.current = null;\n        this.currentName = null;\n        this.star_sx = 64;\n        this.star_sy = 64;\n        this.star_cutoff = 12;\n        this.stars = [];\n        this.spots = [];\n        this.backgroundTypes = {\n            loopy: {\n                color: PICO8_COLORS[0],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[0],\n                hfg: PICO8_COLORS[15],\n                pbg: PICO8_COLORS[1],\n                load: ()=>{\n                    this.rand = Array.from({\n                        length: 16384\n                    }, ()=>Math.random() * 16);\n                },\n                update: ()=>{\n                    this.rand.forEach((p, i)=>{});\n                },\n                draw: ()=>{\n                    this.rand.forEach((p, i)=>{\n                        const x = i % 128;\n                        const y = Math.floor(i / 128);\n                        putPixel(x, y, PICO8_COLORS[Math.floor(p)]);\n                    });\n                }\n            },\n            flurry: {\n                color: PICO8_COLORS[0],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[0],\n                hfg: PICO8_COLORS[15],\n                pbg: PICO8_COLORS[1],\n                load: ()=>{\n                    this.rand = [];\n                    this.rand2 = [];\n                    for(let n = 0; n < 256; n++){\n                        this.rand.push(Math.random() * 128);\n                        this.rand2.push(Math.random() * 128);\n                    }\n                },\n                draw: ()=>{\n                    const p = [\n                        1,\n                        1,\n                        13,\n                        13,\n                        2,\n                        14,\n                        6\n                    ];\n                    for(let i = 0; i < 256; i++){\n                        const z = Math.floor(i / 40) + 1;\n                        drawFilledCircle((this.rand[i] - this.t * z * z) % 140 - 8, this.rand2[i], z, PICO8_COLORS[p[z]] || 0xfe);\n                    }\n                    this.t += 0.05;\n                }\n            },\n            balls: {\n                color: PICO8_COLORS[0],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[2],\n                hfg: PICO8_COLORS[1],\n                pbg: PICO8_COLORS[8],\n                load: ()=>{\n                    for(let n = 0; n < 500; n++)this.rand.push(Math.random() * 9);\n                },\n                draw: ()=>{\n                    for(let i = 0; i < 500; i++){\n                        let p = 9 - i / 50;\n                        let j = (p + Math.sin(this.t) - this.t * 9) % 11 + 0.1;\n                        let k = this.rand[i] - 5 + Math.cos(this.t);\n                        if (Math.floor(p) === 7) p = 14;\n                        drawFilledCircle(k / j * 50 + 64, 80 / j - 20, 9 / j, PICO8_COLORS[Math.floor(p)] || 0xfe);\n                    }\n                    this.t += 0.01;\n                }\n            },\n            rainbow: {\n                color: PICO8_COLORS[2],\n                mfg: PICO8_COLORS[1],\n                mbg: PICO8_COLORS[7],\n                hfg: PICO8_COLORS[2],\n                pbg: PICO8_COLORS[2],\n                draw: ()=>{\n                    const m = 12;\n                    this.t += 0.05;\n                    for(let n = 0; n < m * m; n++){\n                        const x = n % m;\n                        const y = Math.floor(n / m);\n                        drawFilledCircle(x * 12, y * 12, 12 + 4 * Math.cos(this.t + y / 5) + 4 * Math.sin(this.t + x / 7), PICO8_COLORS[8 + (x + y) % 8] || 0xfe);\n                    }\n                }\n            },\n            spiral: {\n                color: PICO8_COLORS[1],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[5],\n                hfg: PICO8_COLORS[6],\n                pbg: PICO8_COLORS[0],\n                draw: ()=>{\n                    const s = 64;\n                    this.t += 0.0001;\n                    let x = s, y = s;\n                    for(let i = 1; i <= 350; i++){\n                        const j = i * this.t;\n                        const u = x, v = y;\n                        x = x + j * Math.sin(j);\n                        y = y + j * Math.cos(j);\n                        drawLine(u, v, x, y, PICO8_COLORS[7 + Math.floor(i / 60)] || 0xfe);\n                    }\n                }\n            },\n            circles: {\n                color: PICO8_COLORS[2],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[1],\n                hfg: PICO8_COLORS[15],\n                pbg: PICO8_COLORS[0],\n                draw: ()=>{\n                    this.t += 0.01;\n                    for(let k = 0; k <= 16; k++)for(let n = 1; n <= 9; n++){\n                        const h = k / 16 + this.t;\n                        drawCircle(64 + Math.cos(h + this.t / 3) * n * 8, 64 + Math.sin(h) * (n * n + Math.cos(this.t) * 16), n, PICO8_COLORS[11 - Math.floor(n / 3)] || 0xfe);\n                    }\n                }\n            },\n            ballspiral: {\n                color: PICO8_COLORS[9],\n                mfg: PICO8_COLORS[0],\n                mbg: PICO8_COLORS[7],\n                hfg: PICO8_COLORS[4],\n                pbg: PICO8_COLORS[4],\n                draw: ()=>{\n                    let x = 64, y = 64, r = 1, a = 0;\n                    for(let i = 0; i <= 150; i++){\n                        drawFilledCircle(x, y, r / 2, PICO8_COLORS[6 + i % 3] || 0xfe);\n                        x += Math.cos(a) * r;\n                        y += Math.sin(a) * r;\n                        r += 1 / 4;\n                        a += this.t / 5;\n                    }\n                    this.t += 0.002;\n                }\n            },\n            grid: {\n                color: PICO8_COLORS[0],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[2],\n                hfg: PICO8_COLORS[13],\n                pbg: PICO8_COLORS[2],\n                draw: ()=>{\n                    const w = 127;\n                    const n = 15;\n                    this.t += 0.75;\n                    for(let i = 0; i <= n; i++){\n                        const z = i * n + this.t % n;\n                        const y = w * n / z + 32;\n                        drawLine(0, y, w, y, PICO8_COLORS[gridcolor]);\n                        const v = i + this.t % n / n - n / 2;\n                        drawLine(v * 9 + 64, 40, v * 60 + 64, w, PICO8_COLORS[gridcolor] || 0xfe);\n                    }\n                }\n            },\n            flight: {\n                color: PICO8_COLORS[0],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[1],\n                hfg: PICO8_COLORS[4],\n                pbg: PICO8_COLORS[5],\n                draw: ()=>{\n                    const n = 32;\n                    const sin_t_over_300 = Math.sin(this.t / 300);\n                    const t_mod_n = this.t % n;\n                    const c = sin_t_over_300;\n                    const sin_t_over_9 = c / 9;\n                    const sin_t_over_3 = c / 3;\n                    const const1 = sin_t_over_3 + 1;\n                    const make = (y, color)=>{\n                        for(let i = 0; i <= n; i++){\n                            const z = (i * n + t_mod_n) / 1500;\n                            for(let j = -n; j <= n; j++){\n                                const x = (j * 0.7 + c) / z + y;\n                                const y_pos = (-j * sin_t_over_9 + const1) / z + y;\n                                putPixel(x, y_pos, PICO8_COLORS[color] || 0xfe);\n                            }\n                        }\n                    };\n                    this.t -= 2;\n                    make(5, 8);\n                    make(40, 9);\n                    make(70, 10);\n                }\n            },\n            matrix: {\n                color: PICO8_COLORS[0],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[3],\n                hfg: PICO8_COLORS[11],\n                pbg: PICO8_COLORS[3],\n                draw: ()=>{\n                    for(let j = 3; j <= 99; j++){\n                        let c = 11;\n                        const x = j * 593;\n                        for(let y = 1; y <= x % c; y++){\n                            const n = Math.pow(j, y) % 7 + 1;\n                            const __char = \"5&y$%z?$*\".charAt(n - 1);\n                            text(x % 126, (this.t + x) * j / 8 % 256 - y * 6, __char, PICO8_COLORS[c] || 0xfe);\n                            c = 3;\n                        }\n                    }\n                    this.t += 0.7;\n                }\n            },\n            starfield: {\n                color: PICO8_COLORS[0],\n                mfg: PICO8_COLORS[7],\n                mbg: PICO8_COLORS[1],\n                hfg: PICO8_COLORS[4],\n                pbg: PICO8_COLORS[5],\n                load: ()=>{\n                    this.stars = [];\n                    this.spots = [];\n                },\n                update: ()=>{\n                    for(let i = 0; i < 2; i++)if (this.stars.length < 100) {\n                        let star = {\n                            x: this.star_sx,\n                            y: this.star_sy,\n                            d: Math.random(),\n                            spd: i + 1\n                        };\n                        let center_x = 64;\n                        let center_y = 64;\n                        let distance = Math.sqrt(Math.pow(star.x - center_x, 2) + Math.pow(star.y - center_y, 2));\n                        while(distance < 32){\n                            star.x = Math.random() * 128;\n                            star.y = Math.random() * 128;\n                            distance = Math.sqrt(Math.pow(star.x - center_x, 2) + Math.pow(star.y - center_y, 2));\n                        }\n                        this.stars.push({\n                            x: this.star_sx,\n                            y: this.star_sy,\n                            d: Math.random(),\n                            spd: i + 1\n                        });\n                    }\n                    this.stars = this.stars.filter((s)=>{\n                        s.d += 1;\n                        s.x += Math.cos(s.d * Math.PI * 2) * s.spd;\n                        s.y += Math.sin(s.d * Math.PI * 2) * s.spd;\n                        if (s.d > this.star_cutoff - s.spd) for(let i = 1; i <= Math.floor(s.spd); i++)this.spots.push({\n                            x: s.x - Math.cos(s.d * Math.PI * 2) * s.spd / i,\n                            y: s.y - Math.sin(s.d * Math.PI * 2) * s.spd / i,\n                            d: s.spd * 2\n                        });\n                        return !(s.x < -32 || s.x > 128 || s.y < -16 || s.y > 128);\n                    });\n                    this.spots = this.spots.filter((s)=>{\n                        s.d -= 1;\n                        return s.d >= 0;\n                    });\n                },\n                draw: ()=>{\n                    this.stars.forEach((s)=>{\n                        putPixel(s.x, s.y, PICO8_COLORS[7]);\n                    });\n                    this.spots.forEach((s)=>{\n                        putPixel(s.x, s.y, PICO8_COLORS[5]);\n                    });\n                }\n            }\n        };\n    }\n    createStar() {\n        const angle = Math.random() * Math.PI * 2;\n        return {\n            x: this.star_sx,\n            y: this.star_sy,\n            d: angle,\n            spd: Math.random() * 0.5 + 0.1\n        };\n    }\n    load(stageId) {\n        let bgp = this.list[stageId];\n        this.current = this.backgroundTypes[bgp];\n        this.currentName = bgp;\n        this.rand = [];\n        this.rand2 = [];\n        this.t = 0;\n        if (this.current && this.current.load) this.current.load();\n    }\n    next() {\n        this.load((this.list.indexOf(this.currentName) + 1) % this.list.length);\n    }\n    update() {\n        this.t += 0.01;\n        if (this.current && this.current.update) this.current.update();\n    }\n    draw() {\n        if (this.current && this.current.draw) this.current.draw();\n    }\n}\nglobal.window = {};\nwindow.global = window;\nwindow.isKeyPressed = (key)=>true;\nwindow.getMouseState = ()=>new Map();\nwindow.fillScreen = (color)=>{};\nwindow.drawFilledRectangle = (x1, y1, x2, y2, color)=>{};\nwindow.drawRect = (x1, y1, x2, y2, color)=>{};\nwindow.drawRectData = (x1, y1, x2, y2, withTransparency, data, zoom)=>{};\nwindow.drawRectDataSlice = (x, y, width, height, sheetSize, sheetX, sheetY, withTransparency, data, zoom)=>{};\nwindow.drawCircle = (x, y, radius, color)=>{};\nwindow.drawFilledCircle = (x, y, radius, color)=>{};\nwindow.setTransparentColor = (color)=>{};\nwindow.drawSprite = (x, y, spriteIndex)=>{};\nwindow.text = (x, y, text1)=>{};\nwindow.log = (message)=>{};\nwindow.quit = ()=>{};\nwindow.readFile = (filename, format)=>{};\nwindow.readCart = (filename)=>{};\nwindow.writeCart = (filename, cart)=>{};\nwindow.putPixel = (x, y, color)=>{};\nwindow.drawLine = (x1, y1, x2, y2, color)=>{};\nwindow.swapColors = (color1, color2)=>{};\nwindow.setClippingRect = (x, y, width, height)=>{};\nglobal.init = ()=>{\n    setTransparentColor(255);\n    state.SPRITES = {\n        CURSOR: 0\n    };\n    state.color = 0;\n    global.frameCount = 0;\n    global.lastFPSUpdate = Date.now();\n    global.currentFPS = 0;\n    const background1 = new Background();\n    background1.load(0);\n    global.background = background1;\n    state.keyStates = {};\n};\nglobal.update = ()=>{\n    Mouse.mouseUpdate(getMouseState());\n    const currentTime = Date.now();\n    const elapsed = currentTime - state.lastUpdateTime;\n    if (elapsed >= state.FRAME_TIME) {\n        global.frameCount++;\n        if (currentTime - global.lastFPSUpdate >= 1000) {\n            global.currentFPS = global.frameCount;\n            global.frameCount = 0;\n            global.lastFPSUpdate = currentTime;\n        }\n    }\n    Object.keys(state.keyStates).forEach((key)=>{\n        if (state.keyStates[key] === 'pressed') state.keyStates[key] = 'held';\n        else if (state.keyStates[key] === 'released') state.keyStates[key] = 'up';\n    });\n    if (isKeyPressed(32)) {\n        if (state.keyStates[32] !== 'held' && state.keyStates[32] !== 'pressed') {\n            state.keyStates[32] = 'pressed';\n            background.next();\n        }\n    } else if (state.keyStates[32] === 'held' || state.keyStates[32] === 'pressed') state.keyStates[32] = 'released';\n    background.update();\n    global.keyJustPressed = false;\n};\nglobal.draw = ()=>{\n    const currentTime = Date.now();\n    const elapsed = currentTime - state.lastDrawTime;\n    fillScreen(0);\n    if (elapsed >= state.FRAME_TIME) {\n        state.lastDrawTime = currentTime - elapsed % state.FRAME_TIME;\n        state.color = (state.color + 1) % 255;\n    }\n    background.draw();\n    text(1, 1, background.currentName || \"\", 0xfe);\n    drawSprite(Mouse.coords.x, Mouse.coords.y, state.SPRITES.CURSOR, false, false);\n};\n"}